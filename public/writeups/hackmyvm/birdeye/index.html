<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="dark">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Birdeye | Hack Stark ×͜×</title>
<meta name="keywords" content="Linux, Privilege Escalation">
<meta name="description" content="Writeup de la máquina Birdeye en HackMyVM.">
<meta name="author" content="">
<link rel="canonical" href="https://hackstark.netlify.app/writeups/hackmyvm/birdeye/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css" integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://hackstark.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hackstark.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hackstark.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hackstark.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://hackstark.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://hackstark.netlify.app/writeups/hackmyvm/birdeye/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel='stylesheet' href='/css/custom.css'>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">

<script src="/js/main.js" defer></script>
<meta property="og:url" content="https://hackstark.netlify.app/writeups/hackmyvm/birdeye/">
  <meta property="og:site_name" content="Hack Stark ×͜×">
  <meta property="og:title" content="Birdeye">
  <meta property="og:description" content="Writeup de la máquina Birdeye en HackMyVM.">
  <meta property="og:locale" content="es">
  <meta property="og:type" content="article">
    <meta property="article:section" content="writeups">
    <meta property="article:published_time" content="2025-11-03T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-11-03T00:00:00+00:00">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Privilege Escalation">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Birdeye">
<meta name="twitter:description" content="Writeup de la máquina Birdeye en HackMyVM.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Writeups",
      "item": "https://hackstark.netlify.app/writeups/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://hackstark.netlify.app/writeups/hackmyvm/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Birdeye",
      "item": "https://hackstark.netlify.app/writeups/hackmyvm/birdeye/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Birdeye",
  "name": "Birdeye",
  "description": "Writeup de la máquina Birdeye en HackMyVM.",
  "keywords": [
    "Linux", "Privilege Escalation"
  ],
  "articleBody": "Vamos a comenzar realizando un reconocimiento en red para encontrar a la maquina con ayuda de Arp-Scan:\narp-scan -I ens33 --localnet --ignoredups Bueno como podemos ver ya hemos identificado a la maquina victima por lo que vamos a intentar identificar el Sistema que esta corre con ayuda del comando ping:\nping -c 1 192.168.1.129 A menos de que por alguna razón este haya sido modificado podríamos intuir un sistema Linux, la distribución seguimos sin conocerla por el momento.\nEn este punto vamos a realizar un escaneo con ayuda de Nmap para ir mirando los puertos que vemos abiertos por ahora y analizarlos a ver que podemos encontrar:\nnmap -p- --open -sS --min-rate 5000 -n -v -Pn 192.168.1.129 -oG allPorts Podemos observar los puertos abiertos, en este punto lo que vamos a hacer es realizar un escaneo mucho mas agresivo para obtener toda la información de estos puertos que figuran como abiertos y de igual forma aremos uso de Nmap:\nnmap -p53,80,5000 -sVC 192.168.1.129 -oN target Podemos observar de forma mucho mas detallada el servicio y la version del mismo que corre en los puertos.\nBueno vemos en si los puertos 80, 53 y 5000 abiertos donde lo que mas llama mi atención es el puerto 80 y el puerto 5000 además de que gracias a la versión del servicio DNS en el puerto 53 nos da indicios de ser una distribución Ubuntu.\nContinuando con lo del puerto 80 y 5000 estos son servicios web por lo que vamos como primer escaneo a usar Whatweb para ver si identificamos las tecnologías usada:\nwhatweb http://192.168.1.129 Perfecto, vemos que es un Apache cosa que ya nos describía también en el escaneo con nmap y vemos algunas cabeceras que podrían ser útiles dependiendo de la situación.\nLo que vamos a hacer es lo mismo para el puerto 5000 a ver si encontramos algo:\nwhatweb http://192.168.1.129:5000 al igual nos habla de Werkzeug y su versión al igual que nos describe la versión de python que esta implementando, lo primero que tenemos que hacer es buscar que es so de Werkzeug para entender que esta pasando primero.\nLo que encontramos es que Werkzeug es una biblioteca de python que nos permite la crear aplicaciones web compatibles con WSGI (Web Server Gateway Interface) que es una interfaz estándar entre servidores web y aplicaciones web en Python el cual permite que servidores como Apache o Nginx se comuniquen con diferentes frameworks como los Django o Flask.\nBueno con esto ya podemos tener una idea de como puede estar montada la web ya que si tenemos esto corriendo podemos asumir que tenemos algún back-end en python que se esta comunicando con apache para servir la información por el puerto 80.\nVamos aver que tenemos entonces en el puerto 80:\nBueno vemos varias opciones donde ya probamos pero no encontramos nada realmente critico por el momento.\nComo no vemos nada por aquí vamos a intentar hacer un poco de fuzzing con gobuster para encontrar directorios en la web. Recordemos que en el puerto 5000 aunque vemos la tecnología no se observaremos nada en absoluto, entonces continuemos con el fuzzing:\ngobuster dir -u http://192.168.1.129 -w /usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt --add-slash -t 20 vemos que tenemos una ruta admin la cual aunque no es accesible podríamos tener algo dentro, así que vamos a intentar ver dentro de la misma: Vemos un error al intentarlo de primeras pero si lo leemos vamos a ver que nos habla de que al parecer no nos admite peticiones largas y nos dice que las limitemos directamente a 22 vamos a hacerlo y ahora si el comando sería:\ngobuster dir -u http://192.168.1.129/admin -w /usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt --add-slash -t 20 -xl 22 vemos que nos redirige a un /config pero que no es accesible, en este punto vamos a navegar en toda la web y realizar diferentes que tenga la web capturando claro todo el trafico mediante el Burpsuite: vemos esta petición que es en el apartado de búsqueda y vemos que al parámetro url le estamos pasando algo pero no se comprende que es, vamos a url-decode a eso a ver que es:\nPerfecto lo que vemos es que estamos haciendo una petición que podría dirigirse también de forma externa, esto no es una buena practica, vemos que pasa si desde aquí llamamos a google: Nos aplica un redirect:\ny pues si logramos pasar a google por lo que la web realiza peticiones.\nEsto ya podemos identificarlo como un Server-Side Request Forgery (SSRF) donde vamos a poder talvez realizar peticiones a webs o servicios internos, en este caso recordemos que tenemos el /admin corriendo pero no tenemos acceso, por concepto debemos pasara debido a que la misma maquina esta haciendoce asia si misma la consulta: vemos que nos aplica un follow redirect:\npero no llegamos a ningún lado.\nrecordemos que dentro de /admin encontramos otra ruta mas que es /config veamos si esto nos da alguna respuesta: Perfecto el servidor nos acaba de responder y lo que vemos son credenciales de adminitrador, además de que nos indica que en /admin/panelloginpage esta el panel de administración por lo que vamos a intentar entrar y ver que es y las credenciales que nos da las vamos a guardar superadmin:SuperSecret123!:\nvemos un panel administrativo.\nde igual forma revisando la respuesta lo que vemos es que podemos emplear 3 tipos de métodos, pero si bajamos y revisamos el código del formulario: como vemos emplea post por lo cual vamos a tener que usarlo de la siguiente manera:\nTodo lo que vemos en la imagen es lo agregado o modificado que nos ayuda a completar correctamente la petición, en este punto lo que vamos a hacer es llevarnos la cookie de sesión que nos responde la web y dirigirnos directamente a admin pero si observamos bien vamos a ver que el titulo de la web es Dashboard podemos intentar en caso de no funcionar ir a /admin/Dashboard a ver que obtenemos:\nvemos que el /admin/dashboard es el valido, además de que la petición gracias a la cookie que tenemos ya podemos hacerla de forma directa.\nEn este punto por alguna razón tenemos una ejecución remota de comandos, vamos a realizar en este punto algo sencillo que es generar una reverse shell para mayor comodidad:\nvemos un pequeño problema en este caso y es que nos esta impidiendo algunas ejecuciones de comandos por lo que nos impide en si cualquier tipo de reverse shell, pero aquí vamos a hacer uso de un binario llamado busybox el cual es un software especialmente usado en sistema embevidos que permite la ejecución de ciertos comandos básicos de Unix, el echo de nosotros mediante este binario podamos realizar una ejecución de comandos es que no hace de intermediario y lanza el binario de ls sino que dentro de el binario de busybox tiene por decirlo de alguna forma una función propia de ls que hace los mismo y es por eso que permite la ejecución de ciertos comandos y con su ayuda vamos a generar la reverse shell:\nPerfecto ya estamos dentro, lo que vamos a hacer ahora es un pequeño tratamiento a la terminal para manejarla mejor:\nPerfecto ahora lo que vamos a hacer es buscar en el sistema por otros usuarios: vemos en /home una carpeta con nombre sev esto nos indica un posible usuario, podemos listar también el /etc/passwd a ver si lo confirmamos:\nefectivamente tenemos al usuario sev y root no tenemos nada mas, podemos ver con sudo -l que permisos de ejecución como sudo tenemos: Perfecto en este punto lo que podemos hacer es intentar ejecutar ese script como sudo como sev de la siguiente manera:\nsudo -u se /home/sev/backup_app.sh Perfecto, vamos a ver la flag y a volver a listar los permisos de sudo:\nvolvemos a observar que podemos usar el comando find, este no es algo que sepamos usar pero podemos ayudarnos de web como GTOBINS a ver que podemos obtener: si tenemos resultado y además si tenemos forma de aprovecharnos de el que se tenga permisos de sudo, vamos ver que podemos hacer:\nComo vemos ya nos dan directamente el comando, en mi caso solo modificare una pequeña cosa y es que quiero que sea una bash y no una sh por lo tanto vamos a intentarlo:\nExcelente ya estamos como usuario root, vamos a intentar en este punto ya obtener la flag de root:\nExcelente, vamos a intentar mandarle ya la ultima flag a Hackmyvm.\n",
  "wordCount" : "1402",
  "inLanguage": "en",
  "datePublished": "2025-11-03T00:00:00Z",
  "dateModified": "2025-11-03T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hackstark.netlify.app/writeups/hackmyvm/birdeye/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Hack Stark ×͜×",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hackstark.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hackstark.netlify.app/" accesskey="h" title="Hack Stark ×͜× (Alt + H)">Hack Stark ×͜×</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://hackstark.netlify.app/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://hackstark.netlify.app/writeups/" title="WriteUps">
                    <span>WriteUps</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Birdeye
    </h1>
    <div class="post-description">
      Writeup de la máquina Birdeye en HackMyVM.
    </div>
    <div class="post-meta"><span title='2025-11-03 00:00:00 +0000 UTC'>November 3, 2025</span>&nbsp;·&nbsp;<span>7 min</span>

</div>
  </header> 
  <div class="post-content"><p>Vamos a comenzar realizando un reconocimiento en red para encontrar a la maquina con ayuda de <strong>Arp-Scan</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>arp-scan -I ens33 --localnet --ignoredups
</span></span></code></pre></div><p><img alt="img1" loading="lazy" src="/img/Pasted%20image%2020251022181804.png"></p>
<p>Bueno como podemos ver ya hemos identificado a la maquina victima por lo que vamos a intentar identificar el Sistema que esta corre con ayuda del comando <code>ping</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ping -c <span style="color:#ae81ff">1</span> 192.168.1.129
</span></span></code></pre></div><p><img alt="img2" loading="lazy" src="/img/Pasted%20image%2020251022181919.png"></p>
<p>A menos de que por alguna razón este haya sido modificado podríamos intuir un sistema <code>Linux</code>, la distribución seguimos sin conocerla por el momento.</p>
<p>En este punto vamos a realizar un escaneo con ayuda de <strong>Nmap</strong> para ir mirando los puertos que vemos abiertos por ahora y analizarlos a ver que podemos encontrar:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nmap -p- --open -sS --min-rate <span style="color:#ae81ff">5000</span> -n -v -Pn 192.168.1.129 -oG allPorts
</span></span></code></pre></div><p><img alt="img3" loading="lazy" src="/img/Pasted%20image%2020251022182404.png"></p>
<p>Podemos observar los puertos abiertos, en este punto lo que vamos a hacer es realizar un escaneo mucho mas agresivo para obtener toda la información de estos puertos que figuran como abiertos y de igual forma aremos uso de <strong>Nmap</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nmap -p53,80,5000 -sVC 192.168.1.129 -oN target
</span></span></code></pre></div><p><img alt="img4" loading="lazy" src="/img/Pasted%20image%2020251022182710.png"></p>
<p>Podemos observar de forma mucho mas detallada el servicio y la version del mismo que corre en los puertos.</p>
<p>Bueno vemos en si los puertos 80, 53 y 5000 abiertos donde lo que mas llama mi atención es el puerto 80 y el puerto 5000 además de que gracias a la versión del servicio <code>DNS</code> en el puerto 53 nos da indicios de ser una distribución Ubuntu.</p>
<p>Continuando con lo del puerto 80 y 5000 estos son servicios web por lo que vamos como primer escaneo a usar <strong>Whatweb</strong> para ver si identificamos las tecnologías usada:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>whatweb http://192.168.1.129
</span></span></code></pre></div><p><img alt="img5" loading="lazy" src="/img/%7B5995BA3F-D558-4ED1-9C28-57433283EC32%7D.png"></p>
<p>Perfecto, vemos que es un Apache cosa que ya nos describía también en el escaneo con nmap y vemos algunas cabeceras que podrían ser útiles dependiendo de la situación.</p>
<p>Lo que vamos a hacer es lo mismo para el puerto 5000 a ver si encontramos algo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>whatweb http://192.168.1.129:5000
</span></span></code></pre></div><p><img alt="img6" loading="lazy" src="/img/Pasted%20image%2020251022183606.png"></p>
<p>al igual nos habla de <code>Werkzeug</code> y su versión al igual que nos describe la versión de python que esta implementando, lo primero que tenemos que hacer es buscar que es so de <code>Werkzeug</code> para entender que esta pasando primero.</p>
<p>Lo que encontramos es que <code>Werkzeug</code> es una biblioteca de python que nos permite la crear aplicaciones web compatibles con <code>WSGI</code> (Web Server Gateway Interface) que es una interfaz estándar entre servidores web y aplicaciones web en Python el cual permite que servidores como <code>Apache</code> o Nginx se comuniquen con diferentes frameworks como los Django o Flask.</p>
<p>Bueno con esto ya podemos tener una idea de como puede estar montada la web ya que si tenemos esto corriendo podemos asumir que tenemos algún back-end en python que se esta comunicando con apache para servir la información por el puerto 80.</p>
<p>Vamos aver que tenemos entonces en el puerto 80:</p>
<p><img alt="img7" loading="lazy" src="/img/Pasted%20image%2020251022185357.png"></p>
<p>Bueno vemos varias opciones donde ya probamos pero no encontramos nada realmente critico por el momento.</p>
<p>Como no vemos nada por aquí vamos a intentar hacer un poco de fuzzing con <code>gobuster</code> para encontrar directorios en la web. Recordemos que en el puerto 5000 aunque vemos la tecnología no se observaremos nada en absoluto, entonces continuemos con el fuzzing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gobuster dir -u http://192.168.1.129 -w /usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt --add-slash -t <span style="color:#ae81ff">20</span>
</span></span></code></pre></div><p><img alt="img8" loading="lazy" src="/img/Pasted%20image%2020251022185749.png"></p>
<p>vemos que tenemos una ruta <code>admin</code> la cual aunque no es accesible podríamos tener algo dentro, así que vamos a intentar ver dentro de la misma:
<img alt="img9" loading="lazy" src="/img/%7BB11DB4AE-97BA-4514-AF36-21D33FB1837A%7D.png"></p>
<p>Vemos un error al intentarlo de primeras pero si lo leemos vamos a ver que nos habla de que al parecer no nos admite peticiones largas y nos dice que las limitemos directamente a <code>22</code> vamos a hacerlo y ahora si el comando sería:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gobuster dir -u http://192.168.1.129/admin -w /usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt --add-slash -t <span style="color:#ae81ff">20</span> -xl <span style="color:#ae81ff">22</span>
</span></span></code></pre></div><p><img alt="img10" loading="lazy" src="/img/Pasted%20image%2020251023162240.png"></p>
<p>vemos que nos redirige a un <code>/config</code> pero que no es accesible, en este punto vamos a navegar en toda la web y realizar diferentes que tenga la web capturando claro todo el trafico mediante el Burpsuite:
<img alt="img11" loading="lazy" src="/img/%7B632ACBF9-D02D-439F-8AEF-773CBBE18A5A%7D.png"></p>
<p>vemos esta petición que es en el apartado de búsqueda y vemos que al parámetro <code>url</code> le estamos pasando algo pero no se comprende que es, vamos a url-decode a eso a ver que es:</p>
<p><img alt="img12" loading="lazy" src="/img/Pasted%20image%2020251023162803.png"></p>
<p>Perfecto lo que vemos es que estamos haciendo una petición que podría dirigirse también de forma externa, esto no es una buena practica, vemos que pasa si desde aquí llamamos a google:
<img alt="img13" loading="lazy" src="/img/%7BBD51EE5B-76C7-4D56-BE66-28BE0E9841F2%7D.png"></p>
<p>Nos aplica un redirect:</p>
<p><img alt="img14" loading="lazy" src="/img/%7B97931A7C-393E-493C-9465-BEB13516BB67%7D.png"></p>
<p>y pues si logramos pasar a google por lo que la web realiza peticiones.</p>
<p>Esto ya podemos identificarlo como un <strong>Server-Side Request Forgery (SSRF)</strong> donde vamos a poder talvez realizar peticiones a webs o servicios internos, en este caso recordemos que tenemos el <code>/admin</code> corriendo pero no tenemos acceso, por concepto debemos pasara debido a que la misma maquina esta haciendoce asia si misma la consulta:
<img alt="img15" loading="lazy" src="/img/%7B8F2FEF78-FB17-41F6-94CE-939615C2B43F%7D.png"></p>
<p>vemos que nos aplica un follow redirect:</p>
<p><img alt="img16" loading="lazy" src="/img/%7B1D5FB8FE-9337-4222-ABA2-72E432992813%7D.png"></p>
<p>pero no llegamos a ningún lado.</p>
<p>recordemos que dentro de <code>/admin</code> encontramos otra ruta mas que es <code>/config</code> veamos si esto nos da alguna respuesta:
<img alt="img17" loading="lazy" src="/img/%7B15779616-E313-4A4B-A605-73E57308D0ED%7D.png"></p>
<p>Perfecto el servidor nos acaba de responder y lo que vemos son credenciales de adminitrador, además de que nos indica que en <code>/admin/panelloginpage</code> esta el panel de administración por lo que vamos a intentar entrar y ver que es y las credenciales que nos da las vamos a guardar <code>superadmin:SuperSecret123!</code>:</p>
<p><img alt="img18" loading="lazy" src="/img/%7B197736D1-7EE2-41F1-8BB4-5595F0BDACC7%7D.png"></p>
<p>vemos un panel administrativo.</p>
<p><img alt="img19" loading="lazy" src="/img/Pasted%20image%2020251023163842.png"></p>
<p>de igual forma revisando la respuesta lo que vemos es que podemos emplear 3 tipos de métodos, pero si bajamos y revisamos el código del formulario:
<img alt="img20" loading="lazy" src="/img/%7B0E646776-FBB6-4BA9-8157-59861C870012%7D.png"></p>
<p>como vemos emplea post por lo cual vamos a tener que usarlo de la siguiente manera:</p>
<p><img alt="img21" loading="lazy" src="/img/Pasted%20image%2020251023170305.png"></p>
<p>Todo lo que vemos en la imagen es lo agregado o modificado que nos ayuda a completar correctamente la petición, en este punto lo que vamos a hacer es llevarnos la cookie de sesión que nos responde la web y dirigirnos directamente a <code>admin</code> pero si observamos bien vamos a ver que el titulo de la web es <code>Dashboard</code> podemos intentar en caso de no funcionar ir a <code>/admin/Dashboard</code> a ver que obtenemos:</p>
<p><img alt="img22" loading="lazy" src="/img/%7B59B077A5-8E5D-410F-8E49-024131A3D666%7D.png"></p>
<p>vemos que el <code>/admin/dashboard</code> es el valido, además de que la petición gracias a la cookie que tenemos ya podemos hacerla de forma directa.</p>
<p>En este punto por alguna razón tenemos una ejecución remota de comandos, vamos a realizar en este punto algo sencillo que es generar una reverse shell para mayor comodidad:</p>
<p><img alt="img23" loading="lazy" src="/img/Pasted%20image%2020251023185645.png"></p>
<p>vemos un pequeño problema en este caso y es que nos esta impidiendo algunas ejecuciones de comandos por lo que nos impide en si cualquier tipo de reverse shell, pero aquí vamos a hacer uso de un binario llamado <code>busybox</code> el cual es un software especialmente usado en sistema embevidos que permite la ejecución de ciertos comandos básicos de Unix, el echo de nosotros mediante este binario podamos realizar una ejecución de comandos es que no hace de intermediario y lanza el binario de <code>ls</code> sino que dentro de el binario de <code>busybox</code> tiene por decirlo de alguna forma una función propia de ls que hace los mismo y es por eso que permite la ejecución de ciertos comandos y con su ayuda vamos a generar la reverse shell:</p>
<p><img alt="img24" loading="lazy" src="/img/Pasted%20image%2020251023191653.png"></p>
<p>Perfecto ya estamos dentro, lo que vamos a hacer ahora es un pequeño tratamiento a la terminal para manejarla mejor:</p>
<p><img alt="img25" loading="lazy" src="/img/Pasted%20image%2020251023191807.png">
<img alt="img26" loading="lazy" src="/img/Pasted%20image%2020251023191827.png"></p>
<p>Perfecto ahora lo que vamos a hacer es buscar en el sistema por otros usuarios:
<img alt="img27" loading="lazy" src="/img/%7BC3FB1DB5-BAEB-4108-BAB1-8CDBE2A1A590%7D.png"></p>
<p>vemos en <code>/home</code> una carpeta con nombre <code>sev</code> esto nos indica un posible usuario, podemos listar también el <code>/etc/passwd</code> a ver si lo confirmamos:</p>
<p><img alt="img28" loading="lazy" src="/img/%7BD9C785A4-A029-4D6A-AA71-A15466E2F221%7D.png"></p>
<p>efectivamente tenemos al usuario <code>sev y root</code> no tenemos nada mas, podemos ver con <code>sudo -l</code> que permisos de ejecución como sudo tenemos:
<img alt="img29" loading="lazy" src="/img/%7BF3A7BCFB-C2F5-465A-A78C-DA9C44251CB6%7D.png"></p>
<p>Perfecto en este punto lo que podemos hacer es intentar ejecutar ese script como sudo como <code>sev</code> de la siguiente manera:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo -u se /home/sev/backup_app.sh
</span></span></code></pre></div><p><img alt="img30" loading="lazy" src="/img/%7BB20BA26B-659F-422E-AFBF-43F364F24334%7D.png"></p>
<p>Perfecto, vamos a ver la flag y a volver a listar los permisos de sudo:</p>
<p><img alt="img31" loading="lazy" src="/img/%7B6248D655-2335-4497-B649-3993A29DF75A%7D.png"></p>
<p>volvemos a observar que podemos usar el comando find, este no es algo que sepamos usar pero podemos ayudarnos de web como GTOBINS a ver que podemos obtener:
<img alt="img32" loading="lazy" src="/img/Pasted%20image%2020251023192740.png"></p>
<p>si tenemos resultado y además si tenemos forma de aprovecharnos de el que se tenga permisos de sudo, vamos ver que podemos hacer:</p>
<p><img alt="img33" loading="lazy" src="/img/%7B398B799A-CB54-4986-8184-D5B0EFD65D61%7D.png"></p>
<p>Como vemos ya nos dan directamente el comando, en mi caso solo modificare una pequeña cosa y es que quiero que sea una <code>bash</code> y no una <code>sh</code> por lo tanto vamos a intentarlo:</p>
<p><img alt="img34" loading="lazy" src="/img/%7B59DC19DD-1C5D-45A7-8BEF-F9D9E55B4CF6%7D.png"></p>
<p>Excelente ya estamos como usuario root, vamos a intentar en este punto ya obtener la flag de root:</p>
<p><img alt="img35" loading="lazy" src="/img/%7B5542378E-1BD2-4307-B5C3-C579672A66B1%7D.png"></p>
<p>Excelente, vamos a intentar mandarle ya la ultima flag a Hackmyvm.</p>
<p><img alt="img36" loading="lazy" src="/img/%7B0FD9303B-D1EA-4BAB-946E-5A2B9F8F00EB%7D.png"></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://hackstark.netlify.app/tags/linux/">Linux</a></li>
      <li><a href="https://hackstark.netlify.app/tags/privilege-escalation/">Privilege Escalation</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://hackstark.netlify.app/">Hack Stark ×͜×</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
