<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="dark">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>RealSaga | Hack Stark ×͜×</title>
<meta name="keywords" content="">
<meta name="description" content="Writeup de la máquina SilentDev en HackMyVM.">
<meta name="author" content="">
<link rel="canonical" href="https://hackstark.netlify.app/writeups/hackmyvm/realsaga/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css" integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://hackstark.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hackstark.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hackstark.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hackstark.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://hackstark.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://hackstark.netlify.app/writeups/hackmyvm/realsaga/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel='stylesheet' href='/css/custom.css'>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">

<script src="/js/main.js" defer></script>

<link rel="icon" type="image/png" href="/images/logo.png">
<link rel="apple-touch-icon" href="/images/logo.png">
<link rel="shortcut icon" href="/images/logo.png">
<meta name="theme-color" content="#2E3440">
<meta property="og:url" content="https://hackstark.netlify.app/writeups/hackmyvm/realsaga/">
  <meta property="og:site_name" content="Hack Stark ×͜×">
  <meta property="og:title" content="RealSaga">
  <meta property="og:description" content="Writeup de la máquina SilentDev en HackMyVM.">
  <meta property="og:locale" content="es">
  <meta property="og:type" content="article">
    <meta property="article:section" content="writeups">
    <meta property="article:published_time" content="2026-01-25T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-25T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RealSaga">
<meta name="twitter:description" content="Writeup de la máquina SilentDev en HackMyVM.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Writeups",
      "item": "https://hackstark.netlify.app/writeups/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://hackstark.netlify.app/writeups/hackmyvm/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "RealSaga",
      "item": "https://hackstark.netlify.app/writeups/hackmyvm/realsaga/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RealSaga",
  "name": "RealSaga",
  "description": "Writeup de la máquina SilentDev en HackMyVM.",
  "keywords": [
    
  ],
  "articleBody": "Reconocimiento Comenzamos identificando la máquina en red, esto con ayuda de [[Arp-Scan]]:\narp-scan -I ens33 --localnet --ignoredups Como podemos observar, la IP de la máquina víctima es 192.168.1.99. A continuación vamos a intentar intuir el sistema operativo a partir de su ttl, esto con ayuda del comando ping:\nping -c 1 192.168.1.99 Tenemos un ttl=64, esto nos permite intuir un sistema basado en Linux.\nComenzamos con un escaneo activo inicial, solo para identificar en su mayoría los puertos expuestos, esto con ayuda de [[Nmap]]:\nnmap -p- --open -sS --min-rate 5000 -n -v -Pn 192.168.1.99 -oG allPorts Se identifican los puertos 25 y 80 abiertos, y ya podemos ver que corren los servicios de smtp y http, respectivamente.\nCentrándonos en estos dos puertos, vamos a realizar un escaneo más agresivo para intentar obtener información de estos servicios de la siguiente manera:\nnmap -p80,25 -sVC 192.168.1.99 -oN target Como podemos observar, tenemos cierta información extra sobre la máquina víctima. En este caso específico, lo que podemos observar es que el servicio del puerto 25 es un Postfix smtp, además tenemos el puerto 80 donde logramos ver dos cosas interesantes: la versión de Apache, que es la 2.4.29, y el http-title, donde lo que logro observar es un saga.local, lo que me intenta decir que tiene ese dominio asociado. Con esto en mente, procedo a configurar el dominio perteneciente a la IP de la máquina víctima para evitar problemas.\nAhora vamos a identificar las tecnologías con ayuda de [[Whatweb]] y Wappalyzer para tener una idea de lo que tenemos corriendo:\nDe entre todo lo que podemos observar, nos vamos a fijar directamente en WordPress, y vamos a volver a utilizar [[Nmap]] con uno de sus scripts, que es http-enum, para ver si logramos encontrar algo:\nnmap --script='http-enum' -p80 192.168.1.99 -oN WebScan De todo lo que podemos observar, vemos una ruta de un backup el cual no contiene nada, luego vemos un panel de login el cual sí nos puede servir. Por último, no es toda la ruta, pero algo interesante es que se puede ver dentro de wp-includes, esto nos puede llevar a hacer una hipótesis donde quizás también logremos ver lo que es la carpeta de wp-content:\nPues sí, logramos acceder, pero no vemos nada. En este punto, y tomando en cuenta que tenemos varios recursos expuestos, vamos a intentar enumerar con ayuda de [[Gobuster]] las rutas de la web de la siguiente manera:\ngobuster dir -u http://saga.local -w /usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt Vemos algunas rutas que ya nos reportó [[Nmap]], pero vamos a intentar ver dentro de wp-content. Recordemos que dentro de esta ruta usualmente se almacena mucha información y complementos de WordPress, por lo que es una buena idea enumerarla:\ngobuster dir -u http://saga.local/wp-content -w /usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt Perfecto, vemos algunas rutas que pueden servir de mucho, como son logs y plugins. Esto es porque, si tenemos logs, podríamos de diversas maneras aprovecharnos de estos para intentar conectarnos a la máquina víctima, pero en este caso la ruta apenas contiene información y no es nada relevante. Con respecto a los plugins, muchas veces los administradores los gestionan mal o no les dan el debido mantenimiento, como son las actualizaciones, lo que provoca que alguno de estos pueda tener una vulnerabilidad conocida o tenga algo expuesto, por lo que vamos a ver si la ruta tiene permisos de directory listing para poder verlos:\nPerfecto, sí nos permite ver los diferentes plugins instalados. Ahora nosotros, de forma manual, podríamos analizar esto desde la web, pero muchas veces, como en este caso que tenemos una cantidad grande de plugins, es mejor descargarlos de forma recursiva con ayuda de wget:\nwget -r http://saga.local/wp-content/plugins Podemos observar ya la carpeta. Algo que personalmente me gusta mucho es jugar con tree para ver primero de forma general qué es lo que tiene el proyecto y luego elimino resultados del tipo png, index, jepg, jpg, svg, gif, css, con el objetivo de reducir la carga visual y analizar lo que nos queda:\ntree | grep -vE 'index|\\.png|\\.gif|\\.jpg|\\.css|\\.svg|\\.jepg' Nuestro árbol visual sigue siendo enorme, aun con los filtros, y no sale todo en la imagen, pero aunque no lo sintamos aún, esto ya nos da una carga visual menor. Ahora, aclaro, no es necesario entender ni analizar cada plugin a profundidad; el propósito es identificar cada uno de los plugins y entender su funcionamiento de forma superficial. A partir de allí es donde este árbol se vuelve importante, y esto es porque ya con una idea de para qué o qué hace el plugin, podemos identificar cosas que nos puedan servir.\nLuego del análisis que mencionamos, tenemos dos plugins que de alguna forma conectan con la información que tenemos y son easy-wp-smtp y contact-form-7, que leyendo un poco descubrimos que pueden llegar a usar el protocolo smtp, y recordando que este servicio está activo, son vectores importantes, por lo que podemos centrarnos en estos dos y vamos a ver con atención sus árboles:\neasy-wp-smtp contact-form-7 Bueno, lo que más por el momento llama mi atención es que tenemos posibles logs visibles. Aunque el archivo está vacío, no vamos a descartar esta opción. En este punto, lo que vamos a hacer es apoyarnos con la herramienta nuclei, recordando y especificando que lo que buscamos es un antes y un después de su ejecución, es decir, ver si algo que nos llama la atención cambia. En mi caso, lo que quiero ver más de cerca es si alguno de los muchos procedimientos que hace nuclei afecta a estos logs y logramos obtener algo, por lo tanto vamos a ejecutar la herramienta de la siguiente manera:\nExplotación nuclei --target http://saga.local No es necesario esperar resultados por parte de la ejecución; podemos intentar ver los archivos que nosotros catalogamos como importantes o que podrían cambiarse, alterarse o modificarse. Tenemos que estar pendientes y ver qué tenemos.\nEn este caso, yo logro ver cómo nuclei, mediante algún proceso que ya veremos si nos reportó, logra que algo active el plugin de easy-wp-smtp y genere logs, que son los siguientes:\nPodemos observar todo eso, y yo ya remarqué cosas que a mí me sirven, como lo son correos y lo que creo que es el vector que tomó de ataque nuclei, que es al parecer un panel de comentarios que nosotros, de forma normal o como usuarios, no logramos observar, pero está allí y está funcionando, por lo que pasemos a ver si nos lo reporta nuclei:\nDe todo eso y más, lo que logra es detectar que tenemos un CVE-2020-35234 correspondiente a nuestro plugin easy-wp-smtp, donde si leemos un poco de información sobre este plugin nos dice que un atacante puede tomar control de cuentas si se encuentra expuesto el archivo *_debug_log.txt, que es el que nosotros detectamos, y al parecer este archivo contiene los enlaces que se envían a los usuarios que intentan restablecer contraseñas, por lo tanto ya tenemos algo significativo.\nEn este punto tenemos que conectar puntos. Recordemos algo, y es que tenemos un panel para hacer login y ahora tenemos algunos correos que podemos intentar, por lo tanto vamos a ver si alguno es válido:\nComo este panel permite enumerar usuarios y correos mediante el mensaje que emite, podemos observar que este correo de administrador existe. Ahora, si nos fijamos, tenemos la opción de restablecer contraseña en el panel, por lo tanto lo que vamos a hacer es intentar restablecerla y ver si al archivo de logs que la aplicación tiene expuesto llega el código o link para cambiar la contraseña del usuario:\nPodemos observar que sí está y encontramos el link. Vamos a cambiar la contraseña del administrador, y algo extra es que tenemos hasta su usuario, que es wpadmin:\nListo, ya establecimos una nueva contraseña, así que vamos a intentar ingresar con las credenciales que se establecieron:\nComo observamos, ya estamos dentro del panel administrativo de WordPress.\nYa en el panel administrativo, tenemos que buscar la forma de lograr una conexión directa al servidor. Para esto, vamos a intentar aprovecharnos de alguno de los plugins instalados; en mi caso voy a usar el de Hello Dolly y en su archivo index.php voy a agregar una línea que nos permita realizar la reverse shell:\nComo podemos observar, ya está listo el archivo. Vamos a guardarlo y, antes de activarlo, dejamos el puerto 443 en escucha:\nAl presionar el botón de activar la extensión que modificamos, se debería establecer la reverse shell:\nEscalada de Privilegios Perfecto, ya podemos dar tratamiento a la terminal y comenzar con un reconocimiento, donde lo primero que se hace es ver el sistema y la IP. El objetivo es identificar dónde estamos:\nComo podemos observar, mediante un uname -a e ip a logramos identificar que es un sistema Linux, específicamente un Ubuntu, pero la IP que nos reporta no es la de la máquina principal, lo que nos lleva a pensar en contenedores.\nCon lo anterior, cuando es un contenedor del tipo Docker, vamos a poder encontrar en la raíz del sistema un archivo oculto con el nombre de .dockerenv:\nLogramos observar que el archivo existe, por lo tanto sabemos con certeza que se trata de un contenedor Docker.\nBueno, en este punto nosotros ya podemos obtener la flag de usuario:\nEl objetivo en este punto es escapar, pero para esto lo mejor será poder tener acceso root dentro del contenedor, por lo que podemos hacer un pequeño reconocimiento:\nComo podemos observar, con sudo -l no logramos observar nada, pero cuando realizamos una búsqueda por archivos SUID con ayuda de find, logramos encontrar que este binario tiene asignados los permisos SUID.\nBueno, cuando tenemos este tipo de permisos, la opción más rápida es buscar por documentación la opción de usar el comando para obtener una shell. En este caso, mediante la web de GTFOBins vemos que ya se tiene un comando válido y es el siguiente:\nfind . -exec /bin/sh -p \\; -quit Como podemos observar, ya tenemos una shell como root.\nEn este punto tenemos que intentar escapar del contenedor. Uno de los métodos que nos permite esto es el uso del archivo docker.sock, el cual solo estará presente si ha sido montado y es accesible desde el contenedor, debido a que a través de este socket es posible interactuar con el daemon de Docker y crear nuevos contenedores. Usualmente este archivo se encontrará dentro de /var/run/docker.sock:\nEn este caso específico, al parecer no tenemos directamente el archivo docker.sock, sino un docker.saga, mediante el cual vamos a intentar hacer la interacción de la siguiente manera:\ndocker -H unix:///var/run/docker.saga images Como podemos observar, sí es posible usar de forma remota el daemon de Docker con ayuda del archivo, por lo que en este punto el procedimiento será crear un nuevo contenedor usando la imagen de Ubuntu, que es la que tenemos ya allí, y montar la raíz del host dentro del mismo de la siguiente manera:\ndocker -H unix:///var/run/docker.saga run -dit -v /:/host f9a80a55f492 Como podemos observar en la imagen, ya tenemos el contenedor creado y corriendo. En este punto, lo que vamos a hacer es, mediante el container ID, conectarnos a él para verificar si se realizó la montura de forma correcta de la siguiente manera:\ndocker -H unix:///var/run/docker.saga exec -it 1cb13e2911dd /bin/bash Como podemos observar, ya estamos dentro del otro contenedor y es cuestión de revisar la montura en /host:\nY con esto terminamos la máquina. Podemos observar cómo sí se montó y ya podemos observar todo el directorio raíz del host dentro del contenedor, por lo cual obtenemos la flag de root.\nLab terminado.\n",
  "wordCount" : "1917",
  "inLanguage": "en",
  "datePublished": "2026-01-25T00:00:00Z",
  "dateModified": "2026-01-25T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hackstark.netlify.app/writeups/hackmyvm/realsaga/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Hack Stark ×͜×",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hackstark.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hackstark.netlify.app/" accesskey="h" title="Hack Stark ×͜× (Alt + H)">Hack Stark ×͜×</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://hackstark.netlify.app/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://hackstark.netlify.app/writeups/" title="WriteUps">
                    <span>WriteUps</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<div class="post-container">
  <article class="post-single">
    <header class="post-header">
      
      <h1 class="post-title entry-hint-parent">
        RealSaga
      </h1>
      <div class="post-description">
        Writeup de la máquina SilentDev en HackMyVM.
      </div>
      <div class="post-meta"><span title='2026-01-25 00:00:00 +0000 UTC'>January 25, 2026</span>&nbsp;·&nbsp;<span>9 min</span>

</div>

      <br />

      <h4>Tags:</h4>

      <br />
      <ul class="post-tags">
      </ul>
    </header> 
    <div class="post-content"><h1 id="reconocimiento">Reconocimiento<a hidden class="anchor" aria-hidden="true" href="#reconocimiento">#</a></h1>
<p>Comenzamos identificando la máquina en red, esto con ayuda de [[Arp-Scan]]:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>arp-scan -I ens33 --localnet --ignoredups
</span></span></code></pre></div><p><img alt="img1" loading="lazy" src="/img/Pasted%20image%2020260124112349.png"></p>
<p>Como podemos observar, la IP de la máquina víctima es <code>192.168.1.99</code>. A continuación vamos a intentar intuir el sistema operativo a partir de su <code>ttl</code>, esto con ayuda del comando ping:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ping -c <span style="color:#ae81ff">1</span> 192.168.1.99
</span></span></code></pre></div><p><img alt="img2" loading="lazy" src="/img/Pasted%20image%2020260124112524.png"></p>
<p>Tenemos un <code>ttl=64</code>, esto nos permite intuir un sistema basado en Linux.</p>
<p>Comenzamos con un escaneo activo inicial, solo para identificar en su mayoría los puertos expuestos, esto con ayuda de [[Nmap]]:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nmap -p- --open -sS --min-rate <span style="color:#ae81ff">5000</span> -n -v -Pn 192.168.1.99 -oG allPorts
</span></span></code></pre></div><p><img alt="img3" loading="lazy" src="/img/Pasted%20image%2020260124112906.png"></p>
<p>Se identifican los puertos 25 y 80 abiertos, y ya podemos ver que corren los servicios de <code>smtp</code> y <code>http</code>, respectivamente.</p>
<p>Centrándonos en estos dos puertos, vamos a realizar un escaneo más agresivo para intentar obtener información de estos servicios de la siguiente manera:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nmap -p80,25 -sVC 192.168.1.99 -oN target
</span></span></code></pre></div><p><img alt="img4" loading="lazy" src="/img/Pasted%20image%2020260124115216.png"></p>
<p>Como podemos observar, tenemos cierta información extra sobre la máquina víctima. En este caso específico, lo que podemos observar es que el servicio del puerto 25 es un <code>Postfix smtp</code>, además tenemos el puerto 80 donde logramos ver dos cosas interesantes: la versión de Apache, que es la 2.4.29, y el <code>http-title</code>, donde lo que logro observar es un <code>saga.local</code>, lo que me intenta decir que tiene ese dominio asociado. Con esto en mente, procedo a configurar el dominio perteneciente a la IP de la máquina víctima para evitar problemas.</p>
<p>Ahora vamos a identificar las tecnologías con ayuda de [[Whatweb]] y Wappalyzer para tener una idea de lo que tenemos corriendo:</p>
<p><img alt="img5" loading="lazy" src="/img/Pasted%20image%2020260124120652.png"></p>
<p><img alt="img6" loading="lazy" src="/img/Pasted%20image%2020260124120731.png"></p>
<p>De entre todo lo que podemos observar, nos vamos a fijar directamente en <code>WordPress</code>, y vamos a volver a utilizar [[Nmap]] con uno de sus scripts, que es <code>http-enum</code>, para ver si logramos encontrar algo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nmap --script<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;http-enum&#39;</span> -p80 192.168.1.99 -oN WebScan
</span></span></code></pre></div><p><img alt="img7" loading="lazy" src="/img/Pasted%20image%2020260124122432.png"></p>
<p>De todo lo que podemos observar, vemos una ruta de un <code>backup</code> el cual no contiene nada, luego vemos un panel de login el cual sí nos puede servir. Por último, no es toda la ruta, pero algo interesante es que se puede ver dentro de <code>wp-includes</code>, esto nos puede llevar a hacer una hipótesis donde quizás también logremos ver lo que es la carpeta de <code>wp-content</code>:</p>
<p><img alt="img8" loading="lazy" src="/img/Pasted%20image%2020260124122708.png"></p>
<p>Pues sí, logramos acceder, pero no vemos nada. En este punto, y tomando en cuenta que tenemos varios recursos expuestos, vamos a intentar enumerar con ayuda de [[Gobuster]] las rutas de la web de la siguiente manera:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gobuster dir -u http://saga.local -w /usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt
</span></span></code></pre></div><p><img alt="img9" loading="lazy" src="/img/Pasted%20image%2020260124122933.png"></p>
<p>Vemos algunas rutas que ya nos reportó [[Nmap]], pero vamos a intentar ver dentro de <code>wp-content</code>. Recordemos que dentro de esta ruta usualmente se almacena mucha información y complementos de WordPress, por lo que es una buena idea enumerarla:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gobuster dir -u http://saga.local/wp-content -w /usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt
</span></span></code></pre></div><p><img alt="img10" loading="lazy" src="/img/Pasted%20image%2020260124123125.png"></p>
<p>Perfecto, vemos algunas rutas que pueden servir de mucho, como son <code>logs</code> y <code>plugins</code>. Esto es porque, si tenemos logs, podríamos de diversas maneras aprovecharnos de estos para intentar conectarnos a la máquina víctima, pero en este caso la ruta apenas contiene información y no es nada relevante. Con respecto a los <code>plugins</code>, muchas veces los administradores los gestionan mal o no les dan el debido mantenimiento, como son las actualizaciones, lo que provoca que alguno de estos pueda tener una vulnerabilidad conocida o tenga algo expuesto, por lo que vamos a ver si la ruta tiene permisos de <em>directory listing</em> para poder verlos:</p>
<p><img alt="img11" loading="lazy" src="/img/Pasted%20image%2020260124123549.png"></p>
<p>Perfecto, sí nos permite ver los diferentes plugins instalados. Ahora nosotros, de forma manual, podríamos analizar esto desde la web, pero muchas veces, como en este caso que tenemos una cantidad grande de plugins, es mejor descargarlos de forma recursiva con ayuda de <code>wget</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget -r http://saga.local/wp-content/plugins
</span></span></code></pre></div><p><img alt="img12" loading="lazy" src="/img/Pasted%20image%2020260124123841.png"></p>
<p>Podemos observar ya la carpeta. Algo que personalmente me gusta mucho es jugar con <code>tree</code> para ver primero de forma general qué es lo que tiene el proyecto y luego elimino resultados del tipo <code>png, index, jepg, jpg, svg, gif, css</code>, con el objetivo de reducir la carga visual y analizar lo que nos queda:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tree | grep -vE <span style="color:#e6db74">&#39;index|\.png|\.gif|\.jpg|\.css|\.svg|\.jepg&#39;</span>
</span></span></code></pre></div><p><img alt="img13" loading="lazy" src="/img/Pasted%20image%2020260124124638.png"></p>
<p>Nuestro árbol visual sigue siendo enorme, aun con los filtros, y no sale todo en la imagen, pero aunque no lo sintamos aún, esto ya nos da una carga visual menor. Ahora, aclaro, no es necesario entender ni analizar cada plugin a profundidad; el propósito es identificar cada uno de los plugins y entender su funcionamiento de forma superficial. A partir de allí es donde este árbol se vuelve importante, y esto es porque ya con una idea de para qué o qué hace el plugin, podemos identificar cosas que nos puedan servir.</p>
<p>Luego del análisis que mencionamos, tenemos dos plugins que de alguna forma conectan con la información que tenemos y son <code>easy-wp-smtp</code> y <code>contact-form-7</code>, que leyendo un poco descubrimos que pueden llegar a usar el protocolo <code>smtp</code>, y recordando que este servicio está activo, son vectores importantes, por lo que podemos centrarnos en estos dos y vamos a ver con atención sus árboles:</p>
<ul>
<li><code>easy-wp-smtp</code></li>
</ul>
<p><img alt="img14" loading="lazy" src="/img/Pasted%20image%2020260124125251.png"></p>
<ul>
<li><code>contact-form-7</code></li>
</ul>
<p><img alt="img15" loading="lazy" src="/img/Pasted%20image%2020260124125324.png"></p>
<p>Bueno, lo que más por el momento llama mi atención es que tenemos posibles logs visibles. Aunque el archivo está vacío, no vamos a descartar esta opción. En este punto, lo que vamos a hacer es apoyarnos con la herramienta <code>nuclei</code>, recordando y especificando que lo que buscamos es un antes y un después de su ejecución, es decir, ver si algo que nos llama la atención cambia. En mi caso, lo que quiero ver más de cerca es si alguno de los muchos procedimientos que hace <code>nuclei</code> afecta a estos logs y logramos obtener algo, por lo tanto vamos a ejecutar la herramienta de la siguiente manera:</p>
<h1 id="explotación">Explotación<a hidden class="anchor" aria-hidden="true" href="#explotación">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nuclei --target http://saga.local
</span></span></code></pre></div><p><img alt="img16" loading="lazy" src="/img/Pasted%20image%2020260124125654.png"></p>
<p>No es necesario esperar resultados por parte de la ejecución; podemos intentar ver los archivos que nosotros catalogamos como importantes o que podrían cambiarse, alterarse o modificarse. Tenemos que estar pendientes y ver qué tenemos.</p>
<p>En este caso, yo logro ver cómo <code>nuclei</code>, mediante algún proceso que ya veremos si nos reportó, logra que algo active el plugin de <code>easy-wp-smtp</code> y genere logs, que son los siguientes:</p>
<p><img alt="img17" loading="lazy" src="/img/Pasted%20image%2020260124130150.png"></p>
<p>Podemos observar todo eso, y yo ya remarqué cosas que a mí me sirven, como lo son correos y lo que creo que es el vector que tomó de ataque <code>nuclei</code>, que es al parecer un panel de comentarios que nosotros, de forma normal o como usuarios, no logramos observar, pero está allí y está funcionando, por lo que pasemos a ver si nos lo reporta <code>nuclei</code>:</p>
<p><img alt="img18" loading="lazy" src="/img/Pasted%20image%2020260124131022.png"></p>
<p>De todo eso y más, lo que logra es detectar que tenemos un <code>CVE-2020-35234</code> correspondiente a nuestro plugin <code>easy-wp-smtp</code>, donde si leemos un poco de información sobre este plugin nos dice que un atacante puede tomar control de cuentas si se encuentra expuesto el archivo <code>*_debug_log.txt</code>, que es el que nosotros detectamos, y al parecer este archivo contiene los enlaces que se envían a los usuarios que intentan restablecer contraseñas, por lo tanto ya tenemos algo significativo.</p>
<p>En este punto tenemos que conectar puntos. Recordemos algo, y es que tenemos un panel para hacer login y ahora tenemos algunos correos que podemos intentar, por lo tanto vamos a ver si alguno es válido:</p>
<p><img alt="img19" loading="lazy" src="/img/Pasted%20image%2020260124131654.png"></p>
<p>Como este panel permite enumerar usuarios y correos mediante el mensaje que emite, podemos observar que este correo de administrador existe. Ahora, si nos fijamos, tenemos la opción de restablecer contraseña en el panel, por lo tanto lo que vamos a hacer es intentar restablecerla y ver si al archivo de logs que la aplicación tiene expuesto llega el código o link para cambiar la contraseña del usuario:</p>
<p><img alt="img20" loading="lazy" src="/img/Pasted%20image%2020260124131902.png"></p>
<p><img alt="img21" loading="lazy" src="/img/Pasted%20image%2020260124132024.png"></p>
<p>Podemos observar que sí está y encontramos el link. Vamos a cambiar la contraseña del administrador, y algo extra es que tenemos hasta su usuario, que es <code>wpadmin</code>:</p>
<p><img alt="img22" loading="lazy" src="/img/Pasted%20image%2020260124132116.png"></p>
<p>Listo, ya establecimos una nueva contraseña, así que vamos a intentar ingresar con las credenciales que se establecieron:</p>
<p><img alt="img23" loading="lazy" src="/img/Pasted%20image%2020260124132217.png"></p>
<p><img alt="img24" loading="lazy" src="/img/Pasted%20image%2020260124132230.png"></p>
<p>Como observamos, ya estamos dentro del panel administrativo de WordPress.</p>
<p>Ya en el panel administrativo, tenemos que buscar la forma de lograr una conexión directa al servidor. Para esto, vamos a intentar aprovecharnos de alguno de los plugins instalados; en mi caso voy a usar el de <code>Hello Dolly</code> y en su archivo <code>index.php</code> voy a agregar una línea que nos permita realizar la reverse shell:</p>
<p><img alt="img25" loading="lazy" src="/img/Pasted%20image%2020260125133741.png"></p>
<p>Como podemos observar, ya está listo el archivo. Vamos a guardarlo y, antes de activarlo, dejamos el puerto 443 en escucha:</p>
<p><img alt="img26" loading="lazy" src="/img/Pasted%20image%2020260125133902.png"></p>
<p><img alt="img27" loading="lazy" src="/img/Pasted%20image%2020260125133932.png"></p>
<p>Al presionar el botón de activar la extensión que modificamos, se debería establecer la reverse shell:</p>
<p><img alt="img28" loading="lazy" src="/img/Pasted%20image%2020260125134040.png"></p>
<h1 id="escalada-de-privilegios">Escalada de Privilegios<a hidden class="anchor" aria-hidden="true" href="#escalada-de-privilegios">#</a></h1>
<p>Perfecto, ya podemos dar tratamiento a la terminal y comenzar con un reconocimiento, donde lo primero que se hace es ver el sistema y la IP. El objetivo es identificar dónde estamos:</p>
<p><img alt="img29" loading="lazy" src="/img/Pasted%20image%2020260125134350.png"></p>
<p>Como podemos observar, mediante un <code>uname -a</code> e <code>ip a</code> logramos identificar que es un sistema Linux, específicamente un Ubuntu, pero la IP que nos reporta no es la de la máquina principal, lo que nos lleva a pensar en contenedores.</p>
<p>Con lo anterior, cuando es un contenedor del tipo Docker, vamos a poder encontrar en la raíz del sistema un archivo oculto con el nombre de <code>.dockerenv</code>:</p>
<p><img alt="img30" loading="lazy" src="/img/Pasted%20image%2020260125135022.png"></p>
<p>Logramos observar que el archivo existe, por lo tanto sabemos con certeza que se trata de un contenedor Docker.</p>
<p>Bueno, en este punto nosotros ya podemos obtener la flag de usuario:</p>
<p><img alt="img31" loading="lazy" src="/img/Pasted%20image%2020260125135220.png"></p>
<p>El objetivo en este punto es escapar, pero para esto lo mejor será poder tener acceso <code>root</code> dentro del contenedor, por lo que podemos hacer un pequeño reconocimiento:</p>
<p><img alt="img32" loading="lazy" src="/img/Pasted%20image%2020260125135410.png"></p>
<p>Como podemos observar, con <code>sudo -l</code> no logramos observar nada, pero cuando realizamos una búsqueda por archivos SUID con ayuda de <code>find</code>, logramos encontrar que este binario tiene asignados los permisos SUID.</p>
<p>Bueno, cuando tenemos este tipo de permisos, la opción más rápida es buscar por documentación la opción de usar el comando para obtener una shell. En este caso, mediante la web de GTFOBins vemos que ya se tiene un comando válido y es el siguiente:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>find . -exec /bin/sh -p <span style="color:#ae81ff">\;</span> -quit
</span></span></code></pre></div><p><img alt="img33" loading="lazy" src="/img/Pasted%20image%2020260125135712.png"></p>
<p>Como podemos observar, ya tenemos una shell como <code>root</code>.</p>
<p>En este punto tenemos que intentar escapar del contenedor. Uno de los métodos que nos permite esto es el uso del archivo <code>docker.sock</code>, el cual solo estará presente si ha sido montado y es accesible desde el contenedor, debido a que a través de este socket es posible interactuar con el daemon de Docker y crear nuevos contenedores. Usualmente este archivo se encontrará dentro de <code>/var/run/docker.sock</code>:</p>
<p><img alt="img34" loading="lazy" src="/img/Pasted%20image%2020260125140623.png"></p>
<p>En este caso específico, al parecer no tenemos directamente el archivo <code>docker.sock</code>, sino un <code>docker.saga</code>, mediante el cual vamos a intentar hacer la interacción de la siguiente manera:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker -H unix:///var/run/docker.saga images
</span></span></code></pre></div><p><img alt="img35" loading="lazy" src="/img/Pasted%20image%2020260125140847.png"></p>
<p>Como podemos observar, sí es posible usar de forma remota el daemon de Docker con ayuda del archivo, por lo que en este punto el procedimiento será crear un nuevo contenedor usando la imagen de Ubuntu, que es la que tenemos ya allí, y montar la raíz del host dentro del mismo de la siguiente manera:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker -H unix:///var/run/docker.saga run -dit -v /:/host f9a80a55f492
</span></span></code></pre></div><p><img alt="img36" loading="lazy" src="/img/Pasted%20image%2020260125141548.png"></p>
<p>Como podemos observar en la imagen, ya tenemos el contenedor creado y corriendo. En este punto, lo que vamos a hacer es, mediante el <code>container ID</code>, conectarnos a él para verificar si se realizó la montura de forma correcta de la siguiente manera:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker -H unix:///var/run/docker.saga exec -it 1cb13e2911dd /bin/bash
</span></span></code></pre></div><p><img alt="img37" loading="lazy" src="/img/Pasted%20image%2020260125141836.png"></p>
<p>Como podemos observar, ya estamos dentro del otro contenedor y es cuestión de revisar la montura en <code>/host</code>:</p>
<p><img alt="img38" loading="lazy" src="/img/Pasted%20image%2020260125141941.png"></p>
<p>Y con esto terminamos la máquina. Podemos observar cómo sí se montó y ya podemos observar todo el directorio raíz del host dentro del contenedor, por lo cual obtenemos la flag de <code>root</code>.</p>
<p>Lab terminado.</p>
<p><img alt="img39" loading="lazy" src="/img/Pasted%20image%2020260125142107.png"></p>


    </div>

    <footer class="post-footer">
    </footer>
  </article>

  
  <aside id="sidebar-toc">
    <div class="sidebar-title">Contenido</div>
    <ul id="toc-list"></ul>
  </aside>
</div>

<style>
   
  .post-container {
    display: flex;
    flex-direction: row;
    justify-content: flex-start;
    position: relative;
  }

   
  .post-single {
    display: flex;
    flex-direction: column;
    justify-content: center;
    max-width: 850px;
    padding: 1rem 1rem;
  }

   
  #sidebar-toc {
    position: fixed;
    top: 11%;
    right: 20%;
    width: 260px;
    background-color: rgba(25, 25, 25, 0.95);
    border-radius: 12px;
    padding: 15px 20px;
    color: #fff;
    font-size: 14px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    transition: all 0.3s ease;
  }

   
  .sidebar-title {
    font-weight: bold;
    color: #00bfff;
    margin-bottom: 10px;
    text-align: center;
  }

   
  #toc-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  #toc-list li {
    margin: 5px 0;
  }

  #toc-list li.h2 {
    margin-left: 10px;
    font-size: 13px;
  }

  #toc-list li.h3 {
    margin-left: 20px;
    font-size: 12px;
  }

  #toc-list a {
    color: #9ad0ff;
    text-decoration: none;
    transition: color 0.2s ease;
  }

  #toc-list a:hover {
    color: #00bfff;
  }

   

   
  @media (max-width: 1700px) {
    #sidebar-toc {
      right: 15%;
      width: 220px;
      font-size: 13px;
    }
  }

   
  @media (max-width: 1440px) {

    .post-container {
      justify-content: center;
    }

    #sidebar-toc {
      position: fixed;
      top: auto;
      bottom: 20px;
      right: 10%;
      width: auto;
      padding: 10px 14px;
      background-color: rgba(0, 0, 0, 0.8);
      border-radius: 8px;
      font-size: 13px;
      max-height: none;
      overflow: visible;
      cursor: pointer;
    }

    #sidebar-toc::after {
      content: "☰ Contenido";
      color: #00bfff;
      font-weight: bold;
    }

     
    #toc-list,
    .sidebar-title {
      display: none;
    }

     
    #sidebar-toc:hover #toc-list {
      display: block;
      position: absolute;
      right: 0;
      bottom: 40px;
      width: 220px;
      background-color: rgba(25, 25, 25, 0.95);
      border-radius: 8px;
      padding: 10px;
    }

    #sidebar-toc:hover .sidebar-title {
      display: block;
      text-align: center;
      margin-bottom: 5px;
    }
  }
</style>


<script>
  document.addEventListener("DOMContentLoaded", function () {
    const content = document.querySelector(".post-content");
    const tocList = document.getElementById("toc-list");
    if (!content || !tocList) return;

    const headings = content.querySelectorAll("h1, h2, h3");
    headings.forEach((heading, index) => {
      const id = heading.id || `section-${index}`;
      heading.id = id;

      const li = document.createElement("li");
      li.classList.add(heading.tagName.toLowerCase());

      const a = document.createElement("a");
      a.href = `#${id}`;
      a.textContent = heading.textContent;

      li.appendChild(a);
      tocList.appendChild(li);
    });
  });
</script>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://hackstark.netlify.app/">Hack Stark ×͜×</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
